Doesn't work simply to expand refs in <interleave> because it may interfere with pattern moving.

Map

  foo = element bar|baz { xyzzy }

<xs:group name="foo">
  <xs:choice>
    <xs:element name="bar" type="foo"/>
    <xs:element name="baz" type="foo"/>
  </xs:choice>
</xs:group>

<xs:complexType name="foo">
  xyzzy
</xs:complexType>

Choose name of generated schema file better when there was no prefix.
- use Context to find prefix
- use last component of namespace URI

Use global attributes for cross-schema references.

Make choice of targetNamespace not depend on order of hash table iteration.

Avoid duplicate attributes.

Deal with <ref> to attributes inside optional.

Attribute wildcards

Element wildcards

Nested grammars
- check and give an error
- handle some cases
- expand when necessary

Include overrides
- Check and give error
- Handle overrides

combine attributes
- combine="choice" on <start>
- combine in a single file
- combine="interleave" (if only referenced once, expand?)
- others

externalRef
- detect and give error
- handle
- remember problem with parentRef in externalRef

Check for ref loops

Check for undefined refs

Check for RNG contextual constraints

Take advantage of xs:all.

Avoid introducing ambiguities when approximating <interleave>, eg x & (y, y).

NOTATION datatypes

Multiple pattern parameters

Use complexType in place of group: <define> that contains both
attributes or text and elements and sometimes referenced as a
complexType, then define as complexType.

Deal with xsi attributes.

Make use of element substitution groups; may affect which elements are global.

Deal with comments

Deal with annotations

Deal with a:documentation

Take advantage of type attribute in output.

Push minOccurs down onto single child.

Approximation warnings:
- interleave
- mixed text
- simple type list
- attribute choice
- unknown datatypes

-----

Strategy for handling namespaces

- assign a target namespace to each source URI based on counting attribute and element declarations
in the file (what if no attribute or element declarations?); don't count declarations within
element and attribute declarations

- assign a unique prefix to each target namespace

- for each target namespace, there must be an output schema to serve as the head of that namespace;
if one of the source files with that target namespace directly or indirectly contains all other
files with that target namespace, use that source file as the head; otherwise create a new
file to be the head whose name is based on the prefix

- if a declaration of an element or attribute with some target namespace occurs in a file
which has been assigned a different target namespace, add to list of orphaned elements/attributes

- when outputting, add orphanned elements/attributes to head

- if a file F with target namespace x includes a file G with another target namespace, pretend that
the includes of G occured in F

- generate imports to the heads of all target namespaces



