For each group name
- set of names of groups in which referenced in head position
- set of elements in which referenced in head position
- flag saying whether referenced not in head position

For each attrubute group name
- set of elements in which referenced
- set of names of attibute groups in whch referenced

For each simple type name
- set of elements in which referenced
- set of names of simple types in which referenced as only thing


Check for RNG contextual constraints

Approximation warnings:
- interleave
- mixed text
- simple type list
- attribute choice
- wildcards

Provide annotation to control which target namespace is assigned to a file.

Take advantage of minOccurs > 1 and 1 < maxOccurs < infinity.

If expansion of a group causes the group to become unreferenced, then remove the group.

Map

  foo = element bar|baz { xyzzy }

<xs:group name="foo">
  <xs:choice>
    <xs:element name="bar" type="foo"/>
    <xs:element name="baz" type="foo"/>
  </xs:choice>
</xs:group>

<xs:complexType name="foo">
  xyzzy
</xs:complexType>

Use complexType in place of group: <define> that contains both
attributes or text and elements and sometimes referenced as a
complexType, then define as complexType.

Use the last component of the namespace URI in selecting prefix and generated schema file when no prefix is used in the
RELAX NG.

Try using default namespace declaration to refer to things in targetNamespace.

Make choice of targetNamespace not depend on order of hash table iteration.

Handle nested grammars (use different namespace for different grammars).

Handle include overrides: (1) resolve (2) turn into <redefine>.

Preserve definitions that are equivalent to empty or notAllowed.

Handle externalRef (remember problem with parentRef in externalRef)

Interleave
- Avoid introducing ambiguities when approximating <interleave>, eg x & (y, y).
- Take advantage of xs:all.
- Optimize nested choices in expanding <interleave>.
- Optimize eg x* & (a, b, c) into x*, (a, x*), (b, x*), (c, x*)

For a <value type="NOTATION"/>, map to NOTATION and generate an appropriate xs:notation declaration
based on annotations.

Deal with xsi attributes.

Make use of element substitution groups; may affect which elements are global.

Deal with comments

Deal with annotations

Deal with a:documentation

Deal with element type consistent restriction

Deal with ambiguous content model restriction

Support attribute defaults (should be field on OptionalAttribute).

Avoid redundant imports and redundant namespace declarations.
