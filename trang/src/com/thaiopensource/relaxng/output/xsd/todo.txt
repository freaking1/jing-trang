Use global element declarations
- when only one element of particular name
- when multiple elements, but only one occurs as the sole content of a define
- when there's something we want to use in a subsitution group

Avoid duplicate attributes.

Deal with <ref> to attributes inside optional.

Name classes
- choice
- attribute wildcards
- element wildcards

Nested grammars
- check and give an error
- handle some cases
- expand when necessary

Allow attribute names with empty namespace or target namespace

Allow local elements with empty namespace

Namespaces
- check for single namespace
- allow multiple namespaces but not mixed in a file
- split files based on namespace
- Need to deal with inherited namespace

Include overrides
- Check and give error
- Handle overrides

combine attributes
- combine="choice" on <start>
- combine in a single file
- combine="interleave"
- others

externalRef
- detect and give error
- handle
- remember problem with parentRef in externalRef

Check for ref loops

Check for undefined refs

Check for RNG contextual constraints

Approximate <interleave>

NOTATION datatypes

Multiple pattern parameters

Use complexType in place of group: <define> that contains both
attributes or text and elements and sometimes referenced as a
complexType, then define as complexType.

Deal with xsi attributes.

Make use of element substitution groups.

Deal with comments

Deal with annotations

Deal with a:documentation

--

Strategy for handling namespaces

- assign a target namespace to each source URI based on counting attribute and element declarations
in the file (what if no attribute or element declarations?); don't count declarations within
element and attribute declarations

- assign a unique prefix to each target namespace

- for each target namespace, there must be an output schema to serve as the head of that namespace;
if one of the source files with that target namespace directly or indirectly contains all other
files with that target namespace, use that source file as the head; otherwise create a new
file to be the head whose name is based on the prefix

- if a declaration of an element or attribute with some target namespace occurs in a file
which has been assigned a different target namespace, add to list of orphaned elements/attributes

- when outputting, add orphanned elements/attributes to head

- if a file F with target namespace x includes a file G with another target namespace, pretend that
the includes of G occured in F

- generate imports to the heads of all target namespaces




